# 03_Props_State_Hooks

## Props

: 부모 컴포넌트가 자식 컴포넌트에게 전달하는 데이터

- Properties의 줄임말
- props를 통해 각각의 컴포넌트에 다른 값을 부여해서 각각 다른 UI를 부여하는 것이 가능하다
- props로 전달할 수 있는 값
    - 숫자나 문자열값은 자바스크립트 값
    - html 요소나 리액트 컴포넌트도 사용 가능
        
        : 닫는 컴포넌트 별도 설정 후 content에 명시 → 객체 내 children 이라는 이름으로 전달됨
        

### 사용 방법

- 부모 컴포넌트 : `key=값`의 형태로 전달 or 객체 변수 정의 후 스프레드 연산자 사용
    - 스프레드 연산자 사용
        
        ```jsx
        function App() {
        
        	const buttonProps = {
        		text: "red";
        		color: "red";
        	}
        	
        	return (
        		<>
        			<Button {...buttonProps} />
        }
        ```
        
- 자식 컴포넌트 : 함수의 인수에 props라는 인수명 or 구조분해할당 사용
    - props 값은 객체 형태로 자식 컴포넌트에 전달됨
    - 중괄호 사용해서 `객체.key` (점표기법)의 형태로 값 사용
    - defaultProps
        
        : 자식 컴포넌트에서 props를 줄 것이라고 생각하고 사용하는 것에 대한 위험 방지
        
        ```jsx
        const Button = (props) => {}
        
        Button.defaultProps = {
        	키:값,
        }
        ```
        
    - props 인자명 대신 구조 분해 할당 적용하기
    : props.color 와 같은 점 표기법 형태에서 축약 사용 가능
        
        ```jsx
        const Button = ({ text, color }) => {}
        ```
        

### props는 읽기 전용으로 자식 컴포넌트는 props를 수정할 수 없다

⇒ 컴포넌트 간의 데이터 흐름을 예측 가능하게 만들고 컴포넌트의 재사용성을 높인다

- 리액트의 단방향 흐름 원칙에 의해 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 단방향으로 전달하도록 설계되었다
- 상태의 변경을 예측할 수 있어 버그 발생 가능성을 줄이고 디버깅을 쉽게 한다
- 내부적으로 변경하지 않기 때문에 재사용성이 높아지고 코드의 캡슐화가 강화된다
- 만약 자식 컴포넌트가 부모로부터 받은 데이터를 수정해야 한다면?
    
    : 상태를 부모 컴포넌트로 올려 부모 컴포넌트에서 props를 다시 전달하는 방식으로 구현해야 한다
    
    ⇒ 상태 끌어올리기
    

## Event Handling

: 웹 내부에서 발생하는 사용자의 행동 (ex. 버튼 클릭, 메시지 입력, 스크롤 등)을 처리하는 것

- 이벤트 핸들러 : 이벤트 발생 시 처리하는 동작에 대해 정의한 함수
    - 설정 방법 : on- 접두사를 사용한 이벤트별 상황 속성에 값으로 전달
        - 값 전달은 중괄호를 사용하며 직접적인 익명 함수를 사용하거나
        별도의 함수를 생성한 후 함수명을 명시해서 사용한다 (함수 호출 결과가 아닌 함수 이름만)
- 이벤트 객체 (SyntheticBaseEvent, 합성 이벤트 객체)
    - 합성 이벤트 : 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태 (규칙)
    (브라우저마다 이벤트 객체 이름이 조금씩 다른 `크로스 브라우징 이슈`를 해결함)
    - 대개 e 또는 event라는 변수명으로 사용

## State (상태)

: 컴포넌트 내부에서 관리되는 데이터

- state는 동적으로 변경될 수 있으며 state를 변경하면 컴포넌트는 다시 렌더링되어 UI가 업데이트된다
(컴포넌트의 렌더링에 영향을 미친다)
- state는 주로 사용자 입력이나 네트워크 요청의 응답에 따라 변하는 데이터를 관리할 때 사용한다

### useState Hook을 사용하여 관리

- 배열 구조 분해를 통해 상태값과 상태를 변경하는 함수를 받아옴
- `const [상태값, 상태변경함수] = useState(초기값)`

### 상태 변경 시 주의사항

- 상태 변경 함수를 호출할 때 이전 상태값에 의존한다면 콜백 함수 형태로 전달
- 객체나 배열의 경우 스프레드 연산자를 사용하여 새로운 참조값 생성
- 상태 변경은 비동기적으로 처리됨

## Hooks

: 리액트 16.8 버전에서 도입된 기능으로, 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 사용할 수 있게 해주는 함수들

### 주요 Hooks

1. useState
    - 상태 관리를 위한 가장 기본적인 Hook
    - 컴포넌트에서 변경 가능한 상태를 관리할 때 사용
    
    ```jsx
    jsx
    Copy
    const [state, setState] = useState(initialState);
    
    ```
    
2. useEffect
    - 컴포넌트의 생명주기와 관련된 작업을 처리
    - 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정
    - 의존성 배열을 통해 실행 시점을 제어
    
    ```jsx
    jsx
    Copy
    useEffect(() => {
    // 수행할 작업
      return () => {
    // 클린업 함수
      }
    }, [의존성배열]);
    
    ```
    
3. useRef
    - DOM 요소에 직접 접근하거나 렌더링과 관계없는 값을 저장할 때 사용
    - 값이 변경되어도 컴포넌트가 리렌더링되지 않음
    
    ```jsx
    jsx
    Copy
    const refContainer = useRef(초기값);
    
    ```
    
4. useMemo
    - 계산 비용이 큰 연산의 결과를 메모이제이션
    - 의존성이 변경될 때만 다시 계산
    
    ```jsx
    jsx
    Copy
    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
    
    ```
    
5. useCallback
    - 함수를 메모이제이션하여 불필요한 리렌더링 방지
    - 주로 자식 컴포넌트에 전달되는 콜백 함수 최적화에 사용
    
    ```jsx
    jsx
    Copy
    const memoizedCallback = useCallback(
      () => {
        doSomething(a, b);
      },
      [a, b],
    );
    
    ```
    

### Hook 사용 규칙:

- 최상위 레벨에서만 호출해야 함 (조건문, 반복문 내부에서 사용 불가)
- 리액트 함수형 컴포넌트 또는 커스텀 Hook 내부에서만 호출 가능
- Hook의 이름은 반드시 'use'로 시작해야 함 (커스텀 Hook 작성 시)