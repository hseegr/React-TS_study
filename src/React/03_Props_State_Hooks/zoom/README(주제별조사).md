# [2주차 스터디] 주제별 조사

날짜: 2024년 12월 18일

# 1. 단방향 데이터 흐름

- **정의**: React는 단방향 데이터 흐름(One-Way Data Flow)을 따릅니다. 이는 데이터가 부모 컴포넌트에서 자식 컴포넌트로만 전달된다는 것을 의미합니다.
- **장점**: 이 구조는 데이터의 흐름을 명확하게 하여 상태 관리와 디버깅을 용이하게 합니다. 부모 컴포넌트가 자식 컴포넌트에게 데이터를 전달하고, 자식 컴포넌트는 필요한 경우 이벤트를 부모에게 다시 전달하여 데이터를 업데이트합니다.

## ⚠️ 단방향 흐름이 사용되는 이유

---

| 이유 | 설명 |
| --- | --- |
| **예측 가능성** | 데이터가 부모에서 자식으로만 전달되어 `어디서 변화가 일어나는지 쉽게` 알 수 있음. |
| **단순함** | 데이터 흐름이 직관적이어서 코드를 이해하고 관리하기 쉬움. |
| **문제 해결 용이** | `데이터 흐름 경로가 명확해` 문제 발생 시 원인을 쉽게 파악할 수 있음. |
| **상태 관리** | 부모 컴포넌트에서 데이터를 중앙 관리하고 자식에게 Props로 전달하여 관리 용이. |
| **성능 최적화** | 필요한 부분만 다시 렌더링하여 불필요한 렌더링을 줄이고 앱 성능 향상. |

## 리액트의 단방향 데이터 흐름과 관련된 트리 구조 및 탑다운 방식

---

| 포인트 | 설명 |
| --- | --- |
| **트리 구조** | 리액트 컴포넌트는 트리 형태로 구성되며, 최상위 컴포넌트가 여러 하위 컴포넌트를 가짐. |
| **탑다운 방식** | 데이터는 부모 컴포넌트에서 자식 컴포넌트로 내려오며, 부모가 자식에게 상태를 Props로 전달. |
| **명확한 흐름** | 데이터가 어디서 오는지와 어떻게 변화하는지를 쉽게 파악할 수 있으며, 오류 분석이 용이. |
| **코드 가독성** | 트리 구조와 탑다운 흐름 덕분에 코드 가독성이 높아지고, 유지보수가 쉬움. |
| **이해 용이성** | 개발자가 컴포넌트의 역할과 데이터 흐름을 명확히 이해할 수 있어 코드 관리가 용이함. |

# 2. 불변성

| 결론 | 내용 |
| --- | --- |
| **불변성** | 리액트에서 `state`와 `props`를 불변으로 다루는 것은 
성능 최적화와 코드 가독성 및 유지보수성을 높이는 중요한 방법이며, 
`데이터 변경을 효율적으로 관리`하고 불필요한 작업을 최소화함. |
- **정의**: `state`와 `props`는 불변(Immutable)으로 다루어져야 합니다. 즉, 기존의 상태를 직접 수정하지 않고, 새로운 상태 객체를 생성하여 반영해야 합니다.
- **예시**: 상태를 업데이트할 때는 스프레드 연산자(...)나 `concat`, `map` 등을 이용해 새로운 배열이나 객체를 반환해야 합니다.
- **장점**: 불변성을 유지하면 리액트가 변경된 부분을 효율적으로 감지할 수 있어 성능 최적화에 도움이 되며, 상태 변화의 추적이 쉬워집니다.

## State와 Props를 불변으로 관리해야하는 이유

---

| 이유 | 설명 |
| --- | --- |
| **1. 참조 비교를 
통한 효율적인 변경 감지** | - **참조 비교**: 리액트는 상태 변경을 감지하기 위해 `객체의 참조를 비교`함. 
  불변성을 유지하면 새로운 객체가 생성되어 이전 객체와 참조가 다르게 됨. |
|  | - **예시**: 배열이나 객체를 수정할 경우, 원래 객체를 변경하면 참조가 동일하게 유지됨. 
   하지만 불변 객체를 유지하면 새로운 객체가 생성되어 변화를 감지함. |
| **2. 효율적인 
리렌더링** | - **최적화된 업데이트**: 상태가 변경된 부분만 리렌더링하여 필요한 컴포넌트만 업데이트 가능. 
  예를 들어, 리스트의 특정 항목만 다시 렌더링함. |
|  | - **성능 향상**: 불변성을 통해 `불필요한 렌더링을 줄이고` 리소스 소모를 최소화하여 애플리케이션 
  성능 향상. |
| **3. 예측 가능성과 
디버깅** | - **상태 변화 추적**: `불변 객체를 사용하면 이전 상태와 현재 상태를 쉽게 비교할 수 있어` 디버깅이 
  용이함. |
|  | - **안정성**: 특정 상태가 주어졌을 때 그 상태가 변경되지 않음으로 인해 코드의 안정성이 높아짐. 
   복잡한 애플리케이션에서 중요함. |

### 관련 예시

---

- **문제 상황**: **만약 `props`가 변경될 때 원본 객체를 직접 수정하게 되면, 리액트는 이전 `props`와 새 `props`를 비교할 수 있는 방법이 없어집니다.**
    - ⚠️ 참고로 : 리액트는 자체적으로 `props`의 변경을 감지하고 비교하는 기능을 가지고 있음
    해당 기능은 기본적으로 `리액트의 랜더링 최적화`와 관련있음
    
    ```jsx
    function MyComponent(props) {
        // 직접 수정
        props.someArray.push(newItem);
    }
    
    ```
    
- **결과**: 이 경우 `someArray`의 참조는 변하지 않기 때문에 리액트는 이 변화가 발생한 것을 알지 못합니다. 따라서 해당 컴포넌트를 리렌더링하지 않습니다. 결국 변화가 발생했음에도 불구하고 UI가 업데이트되지 않는 문제가 생깁니다.
- **해결책**: 객체를 불변으로 유지하면 다음과 같이 새로운 배열을 생성하게 됩니다.
    
    ```jsx
    function MyComponent(props) {
        const newArray = [...props.someArray, newItem]; // 새로운 배열 생성
    }
    
    ```
    

이렇게 하면 리액트가 `newArray`의 참조를 이전과 비교하여 실제로 변화가 발생했음을 감지할 수 있습니다.

### 리액트 랜더링 최적화

---

1. **가상 DOM(Virtual DOM) 생성**: 리액트는 현재 상태와 `props` 값을 바탕으로 가상 DOM을 생성합니다.
2. **변경 감지 및 업데이트**: 이전 **가상 DOM과 새 가상 DOM을 비교하여 변경된 부분을 감지**합니다. 이 과정에서 `props`도 확인하게 됩니다.

### 리액트 랜더링 내부 비교

---

- **참조 비교(Reference Comparison)**: 리액트는 `props`와 `state`의 객체 참조를 비교합니다. 즉, 객체의 메모리 주소가 같은지를 확인하여, 서로 다른 객체라면 변경으로 간주합니다. 이렇게 함으로써 리액트는 효율적으로 상태와 `props`의 변화를 감지합니다.
- **Primitive 값 비교**: 단순한 데이터 타입(예: 숫자, 문자열 등)의 경우, 리액트는 실제 값을 비교합니다.

### 변경 감지의 한계

---

- 비록 리액트가 `props`를 비교하여 변경을 감지할 수 있지만, 심층적으로(`deep comparison`) 비교하지는 않습니다. 즉, 객체 내부의 값이 변경되었더라도, 객체의 참조가 동일하다면 리액트는 이를 변경으로 감지하지 않습니다. 따라서 불변성을 유지하는 것이 매우 중요합니다. 객체의 참조가 변하면, 리액트는 새로운 렌더링을 수행합니다.

# 3. 상태 관리

- **`state`와 `props`의 차이**:
    - **State**: 컴포넌트 내에서 관리되는 데이터로, `컴포넌트의 변화를 반영합`니다. 사용자가 입력하는 값이나 API 호출로 인한 데이터 등 동적인 정보를 담습니다.
    - **Props**: 부모 컴포넌트에서 `자식 컴포넌트로 전달되는 데이터로`, 자식 컴포넌트는 이를 읽기만 할 수 있습니다. 상태 관리의 외부 의존성을 가진다고 볼 수 있습니다.

| 특징 | State | Props |
| --- | --- | --- |
| **변경 가능성** | 내부에서 `직접` 변경 가능 | 읽기 전용, `부모 컴포넌트에서만 변경` 가능 |
| **소속** | 컴포넌트 내에서 관리 | `외부에서 주입`됨 |
| **용도** | `동적` 데이터 저장 (예: 사용자 입력, API 데이터) | 컴포넌트 간 데이터 전달 |
| **렌더링** | 상태가 변경되면 컴포넌트가 `다시 렌더링`됨 | 부모가 변경하면 자식 컴포넌트가 필요시 재렌더링 |

## State (상태)

---

```jsx
import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0); // 상태를 정의

    const increment = () => {
        setCount(count + 1); // 상태를 업데이트
    };

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={increment}>Increment</button>
        </div>
    );
}

```

## Props (속성)

---

```jsx
function ParentComponent() {
    const greeting = "Hello, World!";
    return <ChildComponent message={greeting} />; // props로 자식에게 값 전달
}

function ChildComponent({ message }) {
    return <p>{message}</p>; // props로 전달된 값을 사용
}
```

# 4. Props Drilling

- **정의**: Props Drilling은 필요한 데이터(Props)를 `다수의 중간 컴포넌트`를 거쳐 전달해야 하는 상황을 말합니다.
- **문제점**: 이로 인해 코드가 복잡해지고, 중간 컴포넌트가 `불필요한 Props를 받아야 하는 문제가 발생`합니다.
- **해결 방법**: React Context API를 사용해 전역적으로 상태를 관리하거나, 상태 관리 라이브러리를 사용하여 Props Drilling 문제를 해결할 수 있습니다.

## Props Drilling의 정의

---

**Props Drilling**은 필요한 데이터(Props)가 깊은 컴포넌트 트리를 통해 여러 중간 컴포넌트를 거쳐 전달되는 상황을 의미합니다. 데이터가 부모 컴포넌트에서 자식 컴포넌트로 흐르는 단방향 데이터 흐름에 의해 발생하는 현상입니다.

```jsx
function Grandparent() {
    const user = { name: "Alice" };
    return <Parent user={user} />;
}

function Parent({ user }) {
    return <Child user={user} />;
}

function Child({ user }) {
    return <p>{user.name}</p>;
}

```

위 예시에서 `Grandparent` 컴포넌트는 `user` 객체를 직접 사용하고 싶지만, `Parent`와 `Child` 컴포넌트를 거쳐야만 `user`를 사용할 수 있습니다. `Parent` 컴포넌트는 `user`를 직접 사용하는 것이 아니라 단순히 자식에게 전달하는 역할만 하게 됩니다.

## 문제점

---

| 문제점 | 설명 |
| --- | --- |
| **1) 코딩의 복잡성** | - **불필요한 중간 컴포넌트**: 중간 컴포넌트가 특정 데이터만 전달하는 역할을 하게 되어, 컴포넌트 구조가 복잡해진다.
- 이러한 불필요한 `props` 전파가 많아지면 코드의 가독성이 저하된다. |
| **2) 유지보수의 어려움** | - **상태 변화 관리**: 중간 컴포넌트가 여러 개 있을 경우, 특정 데이터가 변경되었을 때 어떤 컴포넌트가 해당 변경에 영향을 받는지 이해하기 어려워진다. 
- 이는 버그를 발생시키기 쉽고, 디버깅을 복잡하게 만든다. |

## 해결 방법

### 1) React Context API

- **Context API**: 리액트의 Context API를 사용하여 데이터를 전역적으로 관리할 수 있습니다. 이 방법은 데이터가 필요한 컴포넌트가 직접 Context에서 값을 가져올 수 있게 하여, Props Drilling을 피할 수 있습니다.

### 사용 예시

```jsx
import React, { createContext, useContext } from 'react';

// Context 생성
const UserContext = createContext();

function Grandparent() {
    const user = { name: "Alice" };
    return (
        <UserContext.Provider value={user}>
            <Parent />
        </UserContext.Provider>
    );
}

function Parent() {
    return <Child />;
}

function Child() {
    const user = useContext(UserContext); // Context에서 user 값을 가져옴
    return <p>{user.name}</p>;
}

```

### 2) 상태 관리 라이브러리

- **`Redux, MobX, Recoil` 등**: 이런 라이브러리들은 전역 상태 관리 솔루션을 제공합니다. 
중앙 저장소(스토어)에서 데이터를 관리하고, 필요한 컴포넌트가 해당 데이터를 구독하여 사용합니다. 이렇게 하면 Props Drilling을 피할 수 있고, 상태 관리를 효율적으로 할 수 있습니다.

# 5. Redux와 Recoil 같은 상태 관리 라이브러리 비교

## context API와 다른 내용들 비교

---

| 특성 | Redux | Recoil | React Context API |
| --- | --- | --- | --- |
| **개념** | `단일 저장소`를 통한 전역 상태 관리 | `원자 단위`로 세밀하게 상태 관리 | 전역적으로 데이터 공유 |
| **장점** | 예측 가능한 상태 관리, 강력한 도구 지원 | 독립적인 원자 기반 관리, 비동기 관리 지원 | 설정 간단, Props Drilling 문제 해결 |
| **단점** | 복잡한 설정, 보일러플레이트 코드 | 커뮤니티와 생태계가 상대적으로 적음 | 많은 구독으로 인해 성능 저하 가능 |
| **사용 대상** | 큰 규모의 애플리케이션이나 복잡한 상태 관리 | 중간 규모 이상의 애플리케이션에서 적합 | 간단한 상태 관리가 필요한 소규모 애플리케이션 |

## Context API가 편리하지만 관련 라이브러리를 사용하는 이유

---

- **Context API**는 빠르게 설정할 수 있고, 소규모 애플리케이션에 적합하지만, 많은 컴포넌트가 구독하게 되면 `성능 문제`가 발생할 수 있습니다.
- **Redux**는 `큰 규모`의 애플리케이션에서 예측 가능하고 일관된 상태 관리를 제공하지만, 설정이 복잡하고 보일러플레이트 코드가 많습니다.
- **Recoil**은 리액트에 최적화된 상태 관리 솔루션으로, `원자 단위` 관리를 통해 UI 응답성을 높이고 비동기 작업 처리에 유용합니다.

## Redux

---

**핵심 용어**

- 리덕스: 이것은 **상태 관리**를 도와주는 **라이브러리**이다. 즉, 프로그램 내에서 데이터나 정보를 어떻게 관리할지를 쉽게 도와준다.
- 참고 URL !!! : [https://www.youtube.com/watch?v=QZcYz2NrDIs](https://www.youtube.com/watch?v=QZcYz2NrDIs)

## 1. 리덕스의 이해와 상태 관리의 필요성

- 리덕스는 주로 귀찮음을 줄이고 **상태 관리**를 위해 사용된다.
- 웹 개발에서 **컴포넌트**는 함수처럼 사용되며, 스테이트는 변수와 유사한 형태로 업데이트된다.

## 2. 리덕스의 사용 및 장점

- 리덕스 라이브러리를 설치하면 **스테이트를 보관하는 파일**을 만들 수 있다.
- 스토어라는 자바스크립트 파일에 **스테이트들**을 저장하면 모든 컴포넌트가 이 데이터를 쉽게 사용할 수 있다.
- 리덕스를 사용하면 **코드가 짧아지며**, Prop을 전달할 필요가 없어져 개발 효율성이 높아진다.
- 초기 세팅은 별도로 이해할 필요 없이 **복사 붙여넣기로** 간단히 사용할 수 있다.
- 설정 후, 사용자는 다양한 **스테이트 변수**를 생성하고 이를 코드에서 쉽게 사용할 수 있다.

## 3. 상태 관리의 용이성

- 리덕스의 두 번째 장점은 **상태 관리가 용이**하다는 점이다.
- 상태는 스토어 안에 자유롭게 꺼내 쓸 수 있어, 다양한 컴포넌트에서 접근할 수 있다.
- 그러나 상태를 변경하고 싶을 때, 모든 컴포넌트가 동시에 변경 작업을 해야 하는 경우가 있다.
- 잘못된 상태 변화로 인해 예기치 않은 **버그**가 발생할 수 있어, 예를 들어 몸무게가 숫자가 아닌 문자가 되는 경우가 있을 수 있다.
- 이러한 버그를 추적하기 위해서는 각 컴포넌트를 다시 점검해야 하므로, 상태 관리의 복잡성이 증가할 수 있다.

## 4. 리덕스를 통한 관리 효율성 증대

- 리덕스를 사용하면 수백만 개의 **컴포넌트**에서 발생하는 에러 조사 시간을 단축할 수 있다.
- 상태를 수정하기 위해 사전에 수정 방법을 정의해 놓는 것이 중요하다.
- 예를 들어, 특정 상태가 **플러스 1** 또는 **마이너스 2**가 되도록 하는 방식으로 상태를 관리할 수 있다.
- 이와 같은 과정은 API를 만드는 것으로도 비유될 수 있다.

## 5. 리덕스의 상태 관리 방식

- 리덕스에서 컴포넌트는 **상태를 직접 수정하지 않고**, 수정 요청만을 전달하는 방식으로 작동한다.
- 스토어는 요청을 받아 상태를 수정하며, 이 과정에서 **버그나 에러 발생 시 수정이 용이**해진다.
- 상태의 변화는 항상 스토어에서 관리되므로, **상태 수정의 일치를 추적하기가 쉽다**.
- 리덕스를 사용하는 프로젝트는 **상태 수정 방법을 미리 정의**하고, 이를 통해 일관된 상태 관리를 구현할 수 있다.
- `dispatch` 함수를 활용하여 요청을 보내면, **상태 변화를 쉽게 처리할 수 있는 구조가 구성**된다.

## 6. 리덕스 대체 라이브러리들

- 리덕스 문법이 마음에 들지 않는 경우, 백스, 오버 마인드, 리코 등의 **대체 라이브러리**들이 존재한다.
- 이들 라이브러리들은 리덕스와 **동일한 기능**을 제공하므로, 쉽게 사용할 수 있는 대안이 될 수 있다.
- 이러한 대체 라이브러리들을 살펴보면, 상태 관리가 더 **쉬울 수도 있다**.

## Recoil

---

- 참고 URL!!! : [https://www.youtube.com/watch?v=T4QSK3Un4rU](https://www.youtube.com/watch?v=T4QSK3Un4rU) (10분 이후부터 시청)

## 1.  리코일: 간편한 상태 관리

- 리코일은 페이스북에서 개발한 리액트 상태 관리 라이브러리로, 리덕스의 강력한 경쟁자이다.
- 리코일은 간단하게 설계되어 배우기 쉽고, 전역적인 상태를 관리함으로써 불필요한 렌더링을 최소화할 수 있다.
- 전역 상태 관리는 컴포넌트 간의 props 연결을 줄이고 코드량을 줄이며 성능 개선에 기여한다.

## 2. Recoil 전역 상태 관리 방법

- Recoil은 **전역 상태를 관리하는** 라이브러리로, 프로그래밍에서 전역 상태는 버그를 유발할 수 있어 주의가 필요하다.
- 전역 상태를 사용하기 위해 앱에서 사용할 컴포넌트를 지정해야 하며, 예제에서는 index.js가 최상위 컴포넌트이다.
- 컴포넌트를 **RecoilRoot**로 감싸주어야 하며, import { RecoilRoot } from 'recoil'로 컴포넌트를 가져온다.
- App 컴포넌트를 RecoilRoot로 감싸면 전역 상태가 유효하게 사용될 수 있다.

## 3. Recoil을 사용한 상태 관리 구현 과정

![https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/T4QSK3Un4rU/749.jpg](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/T4QSK3Un4rU/749.jpg)

- `count state`를 **Counter**에서 **App** 컴포넌트로 옮기고, 새로운 Recoil 상태를 만들어야 한다.
- 상태를 헷갈리지 않기 위해 `count` 대신 **아이라는 이름**으로 분리하여 atom을 생성한다.
    - `key`와 `defualt`  필요
- `countState`라는 **atom**을 생성할 때, 중복되지 않는 **키**를 이용해 값을 설정하며 기본값은 10이다.
- `useRecoilState`를 활용해 컴포넌트에서 `countState`를 읽어 올 수 있으며, 이는 `useState`와 유사하다.
- 클릭 시 **셋 카운트**가 호출되어 전역 상태를 변경하고 구독 중인 컴포넌트가 다시 렌더링된다.

## 4. Recoil의 셀렉터와 아톰 활용

- **셀렉터**는 아톰을 바탕으로 새로운 값을 생성하는 데 사용되는 도구로, 기본적으로 아톰이 필요하다.
`아톰 : 애플리케이션의 상태를 정의하는 단위`

![image.png](image.png)

- 셀렉터를 배우는 것은 필수는 아니지만, **편리한 도구 가이드**에서는 서버와의 통신 시 리코일 활용 방법이 설명되어 있으므로 참고할 가치가 있다.
- 리코일은 전역 상태로, **useEffect**와 유사한 효과를 주기 위해서는 아톰 이펙트를 사용해야 한다.
- 리코일을 사용할 때 발생할 수 있는 버그를 해결하는 테크닉이 **debugging** 섹션에 포함되어 있어 참고하면 유용하다.
- 리코일에는 다양한 API가 존재하며, 추가적인 기능에 대한 학습을 통해 더 많은 정보를 얻을 수 있다.

## 간단 이해 예시

---

## 1. Redux: 중앙 시장

### 비유

- **개념**: Redux는 마치 도심의 **중앙 시장**처럼 생각해 보세요. 이 시장은 모든 사람들이 한 곳에서 필요한 물건을 사고팔 수 있는 장소입니다.

### 예시

- **상태**: 시장에 있는 모든 상품이 상태입니다. 다양한 상품들이 한 장소에 모여 있습니다.
- **액션**: 상품을 사고 팔기 위한 **주문서**를 작성하는 것입니다. "사겠다!" 또는 "팔겠다!"라는 요청이죠.
- **리듀서**: 시장의 직원이 주문서를 받고, 상품의 재고를 관리하는 방식입니다. 직원은 요청에 따라 상품을 추가하거나 제거합니다.
- **스토어**: 시장 자체가 스토어입니다. 당신은 언제든지 상품을 사거나 판매할 수 있습니다.

### 장점/단점

- **장점**: 중앙에서 모든 상품을 관리하므로 어떤 상품이 어디에 있는지 쉽게 알 수 있습니다. 예측 가능한 체계로 인해 어떤 주문이 있었는지 쉽게 추적할 수 있습니다.
- **단점**: 주문서 작성과 상품 관리가 복잡할 수 있습니다. 대기 줄이 길거나 복잡한 절차로 인해 시간이 오래 걸리기도 하죠.

---

## 2. Recoil: 다양한 동네 가게들

### 비유

- **개념**: Recoil은 여러 개의 **작은 동네 가게**들이 모여 있는 곳입니다. 각 가게는 독립적으로 운영되지만, 필요한 경우 서로 협력하여 물건을 살 수도 있습니다.

### 예시

- **상태**: 각 가게의 재고가 상태입니다. A 가게에는 사과가, B 가게에는 바나나가 있습니다.
- **원자(Atom)**: 각 가게에서 판매하는 특정 상품, 예를 들어 "사과"가 원자입니다. 각각의 상품은 독립적으로 관리됩니다.
- **비동기 처리**: A 가게에서 바나나가 필요할 때 B 가게에 요청할 수 있지만, 기다리는 동안 다른 고객들이 쇼핑을 계속할 수 있습니다.
- **구독**: 한 고객이 특정 상품의 재고를 계속 확인하고 싶다면, 해당 상품의 재고 변화를 구독할 수 있습니다.

### 장점/단점

- **장점**: 각각의 가게가 독립적으로 운영되므로, 한 가게에서 재고가 없어도 다른 가게에서 쉽게 구매할 수 있습니다. 비동기적으로 작업이 이루어질 수 있어 유연합니다.
- **단점**: 동네 가게가 많아지면 모든 가게 간의 협력이 필요할 수 있고, 때로는 어느 가게에서 무엇이 있는지 헷갈릴 수 있습니다.

---

## 3. React Context API: 가족의 공용 주방

### 비유

- **개념**: React Context API는 하나의 **가족의 공용 주방**처럼 생각할 수 있습니다. 가족 구성원 모두가 주방의 재료를 사용하고, 서로 공유하는 공간입니다.

### 예시

- **상태**: 주방의 모든 재료가 상태입니다. 쌀, 채소, 조미료 등 가족이 함께 사용할 수 있는 재료들이죠.
- **데이터 공유**: 가족 구성원은 주방에서 필요한 재료를 자유롭게 가져갑니다. "다음 주에 파스타를 만들고 싶어!"라고 말하면, 필요한 재료를 함께 사용할 수 있습니다.
- **구독**: 누군가가 특정 재료를 가져가거나 추가하면 다른 가족 구성원에게 알림이 갈 수 있습니다. "엄마, 쌀이 다 떨어졌어요!"와 같은 식이죠.

### 장점/단점

- **장점**: 쉽게 사용할 수 있고, 서로 필요한 재료를 빠르게 공유할 수 있습니다. 공용 자원이므로 협력하기 쉽습니다.
- **단점**: 가족 구성원이 너무 많아지면 주방이 혼잡해지고, 자원의 과도한 사용으로 인해 재료가 떨어질 수 있습니다. 즉, 성능 저하가 발생할 수 있습니다.

---

## 요약

| 특성 | Redux | Recoil | React Context API |
| --- | --- | --- | --- |
| **비유** | 중앙 시장 | 여러 작은 동네 가게들 | 가족의 공용 주방 |
| **상태 관리 방식** | 단일 저장소로 관리 | 원자 단위로 독립 관리 | 전역적으로 재료 공유 |
| **장점** | 예측 가능한 관리 | 유연한 비동기 처리 | 간단한 설정 |
| **단점** | 복잡한 설정 | 커뮤니티가 적음 | 성능 저하 가능 |

# 6. React 18의 기능

## 1. 자동 배치 (Auto Batching) : 단일 렌더링으로 묶어 처리

### 자동 배치 이전(React 17 및 이전)

**동작 방식**: 각각의 상태 업데이트가 개별적으로 렌더링을 트리거합니다. 이 경우, 상태 업데이트가 발생할 때마다 UI가 다시 렌더링됩니다.

```jsx
import React, { useState } from 'react';

function CounterComponent() {
    const [count, setCount] = useState(0);
    const [otherState, setOtherState] = useState(false);

    const updateStates = () => {
        setCount(count + 1); // 상태 업데이트 1: count 증가
        setOtherState(prev => !prev); // 상태 업데이트 2: otherState 토글
        // 각각의 상태 업데이트가 개별적으로 렌더링을 발생시킴
    };

    return <button onClick={updateStates}>Update</button>;
}

```

**렌더링 과정**:

- **1차 렌더링**: `setCount(count + 1)` 호출로 인해 UI가 업데이트됨.
- **2차 렌더링**: `setOtherState(prev => !prev)` 호출로 인해 UI가 다시 업데이트됨.
- **결과**: 두 번의 렌더링이 발생하여 성능이 저하되고, UI가 깜박임.

### 자동 배치 이후(React 18)

**동작 방식**: 리액트는 여러 상태 업데이트를 감지하여 **이를 단일 렌더링으로 묶어 처리합니다.**

### 예시: 자동 배치 이후

```jsx
import React, { useState } from 'react';

function CounterComponent() {
    const [count, setCount] = useState(0);
    const [otherState, setOtherState] = useState(false);

    const updateStates = () => {
        setCount(count + 1); // 상태 업데이트 1: count 증가
        setOtherState(prev => !prev); // 상태 업데이트 2: otherState 토글
        // 자동 배치로 인해 두 개의 상태 업데이트가 하나의 렌더링으로 묶임
    };

    return <button onClick={updateStates}>Update</button>;
}

```

**렌더링 과정**:

- **단일 렌더링**: 두 개의 상태 업데이트(`setCount`와 `setOtherState`)가 동시에 발생하지만, 리액트는 이들을 감지하고 단 하나의 렌더링만 수행합니다.
- **결과**: UI가 한 번만 렌더링되어 성능이 향상되고, UI의 깜박임이 줄어듭니다.

## 2. Concurrent Rendering : 상호작용에 즉시 반응
⇒ 리스트의 일부 항목을 먼저 렌더링하고, 이후 나머지 항목을 점진적으로 렌더링

### 이전 방식 (리액트 17 및 이전)

### 동작 방식

- 리액트 17 이전에는 긴 작업이 발생할 경우, 리액트는 해당 작업이 완료될 때까지 사용자 인터페이스(UI)를 차단했습니다. 즉, 긴 `렌더링 작업이 실행되는 동안 UI가 멈추거나 반응하지 않습니다.`

```jsx
import React, { useState } from 'react';

function LongList() {
    const listItems = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);

    return (
        <ul>
            {listItems.map(item => (
                <li key={item}>{item}</li>
            ))}
        </ul>
    );
}

function App() {
    const [showList, setShowList] = useState(false);

    const handleClick = () => {
        setShowList(true);
        // 긴 리스트를 렌더링하는 데 시간이 걸림
    };

    return (
        <div>
            <button onClick={handleClick}>Show Long List</button>
            {showList && <LongList />}
        </div>
    );
}

```

### 문제점

- 사용자가 "Show Long List" 버튼을 클릭하면, 리액트는 `LongList`를 렌더링하기 위해 모든 리스트 항목을 생성합니다. 이때 긴 작업이 발생하여 UI가 업데이트되지 않고, 사용자는 버튼 클릭 후 아무 반응이 없는 것처럼 느낄 수 있습니다. 즉, 리스트가 렌더링되는 동안 "Loading..." 메시지를 보여주거나 UI가 멈춰있는 것처럼 보일 수 있습니다.

### 현재 방식 (리액트 18 이후)

---

### 동작 방식

- 리액트 18에서는 **Concurrent Rendering** 기능을 통해 긴 작업을 나누어 수행할 수 있습니다. 사용자의 상호작용에 즉시 반응하고, 긴 작업은 잠시 수행되도록 조정합니다.

```jsx
import React, { useState } from 'react';

function LongList() {
    const listItems = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);

    return (
        <ul>
            {listItems.map(item => (
                <li key={item}>{item}</li>
            ))}
        </ul>
    );
}

function App() {
    const [showList, setShowList] = useState(false);

    const handleClick = () => {
        setShowList(true);
        // 긴 리스트를 렌더링하는 동안 다른 작업을 처리할 수 있음
    };

    return (
        <div>
            <button onClick={handleClick}>Show Long List</button>
            {showList && <LongList />}
        </div>
    );
}

```

### 개선된 점

- **즉각적인 반응**: 사용자가 버튼을 클릭하면 리액트는 즉시 그 클릭에 대한 반응을 보여주고, 버튼 클릭에 따른 애니메이션 또는 색상 변화가 즉시 발생할 수 있습니다.
- **UI 끊김 방지**: 긴 리스트가 렌더링되는 동안 **리액트는 해당 작업을 나누어 진행**합니다. `예를 들어, 리스트의 일부 항목을 먼저 렌더링하고, 이후 나머지 항목을 점진적으로 렌더링할 수 있습니다.` 이는 사용자가 버튼을 클릭한 후에도 UI가 반응하며, 다른 인터페이스 요소와 상호작용할 수 있도록 합니다.
- **부드러운 사용자 경험**: 결과적으로, 사용자는 긴 리스트가 렌더링되는 동안에도 다른 버튼을 클릭하거나 입력을 할 수 있으며, UI가 멈추지 않고 부드럽게 작동합니다.

## 3. 새로운 Hooks

## **1. `useId`**: 이 Hook은 유니크한 ID를 생성하는 데 사용됩니다. 주로 리스트의 각 요소에 고유한 ID가 필요할 때 유용합니다.

```jsx
const id = useId();

```

### 고유한 ID 생성

---

`useId`는 컴포넌트가 여러 번 렌더링될 때도 고유한 ID를 생성하여, 각 렌더링 간에 ID가 충돌하지 않도록 보장합니다. 이는 특히 동일한 컴포넌트를 여러 번 사용해야 하는 경우 유용합니다.

### 접근성 (Accessibility)

---

라벨과 입력 필드 간의 연결을 필요로 하는 경우, ID를 사용하여 도움을 줄 수 있습니다. 예를 들어, `<label>` 요소와 `<input>` 요소를 연결하기 위해 ID가 필요합니다. **`useId`를 사용하면 각 입력 필드에 대해 유니크한 ID를 쉽게 생성할 수 있습니다.**

### 동적 양식 (Dynamic Forms)

---

동적으로 생성되는 폼이나 리스트에서 각 항목이나 입력 필드에 대해 고유한 ID가 필요할 경우 유용합니다. 예를 들어, 사용자가 여러 번 추가할 수 있는 입력 필드가 있는 양식에서 각 필드가 서로 다른 ID를 갖도록 할 수 있습니다.

```jsx
import React, { useId } from 'react';

function FormComponent() {
    const id = useId(); // 리액트가 관리하는 고유 ID 생성

    return (
        <div>
            <label htmlFor={`${id}-username`}>Username</label>
            <input type="text" id={`${id}-username`} />

            <label htmlFor={`${id}-email`}>Email</label>
            <input type="email" id={`${id}-email`} />
        </div>
    );
}

```

- 고유한 ID가 생성되어 각 `<input>` 필드와 해당 `<label>`이 연결됩니다. 이를 통해 접근성을 높이고, 포컬(포커스) 이동 시 사용자 경험을 개선할 수 있습니다.

## `ref`와의 비교

---

- **기존의 ID 생성 방식**: 예를 들어, `const id = 1;`처럼 고정값을 사용하는 방식은 **각 컴포넌트 인스턴스에서 ID가 충돌할 수 있습니다.** 다수의 컴포넌트가 동일한 ID를 가지게 되어, DOM에서의 고유성이 저하될 수 있습니다.
- **`useId`**: `useId`를 사용하면 항상 고유한 ID가 제공되므로, 여러 인스턴스의 컴포넌트가 렌더링되더라도 문제를 발생시키지 않습니다.

## **`useDeferredValue`**: 이 Hook은 입력 값의 변화를 지연시키는 데 사용됩니다. 예를 들어, 사용자가 입력하는 동안 렌더링 성능을 저하시키지 않기 위해 입력 값의 변화를 늦출 수 있습니다.

```jsx
import React, { useState, useDeferredValue } from 'react';

function SearchComponent() {
    const [inputValue, setInputValue] = useState('');
    const deferredValue = useDeferredValue(inputValue); // 입력 값의 변화를 지연시킴

    const handleChange = (e) => {
        setInputValue(e.target.value); // 사용자가 입력하는 값
    };

    return (
        <div>
            <input
                type="text"
                value={inputValue}
                onChange={handleChange}
                placeholder="Search..."
            />
            <p>Search Term: {deferredValue}</p> {/* 지연된 값 사용 */}
        </div>
    );
}

```

1. **입력 처리**: 사용자가 입력 상자에서 문자를 입력할 때, `handleChange` 함수가 호출되어 `inputValue`의 상태가 업데이트됩니다.
2. **지연된 값 생성**: `useDeferredValue(inputValue)`로 인해 `deferredValue`는 `inputValue`의 변화를 지연시킵니다. 즉, 사용자가 타이핑할 때 `deferredValue`는 즉시 업데이트되지 않고, 사용자가 입력을 멈춘 후에 업데이트됩니다.
3. **렌더링**: UI는 사용자의 입력과 동시에 업데이트 되지 않지만, 최종적으로 입력이 완료된 후에 `deferredValue`를 통해 출력됩니다. 이렇게 하면 중간에 자주 렌더링하는 것이 아니라, 최종적인 입력 값만 렌더링하게 됩니다.

### 주의 사항

- **사용성**: `useDeferredValue`는 입력 필드와 같은 동적 UI에서 성능을 개선하기 위해 사용됩니다. 특히, **API 요청이나 데이터 필터링과 같이 입력 값에 따라 무거운 작업이 진행**될 때 유용합니다.
- **UI 반응성**: 입력 값의 변화를 지연시키는 동안 사용자와의 상호작용이 영향을 받지 않도록 UI를 설계하는 것이 중요합니다. 즉, 즉각적인 피드백은 여전히 제공되어야 합니다.